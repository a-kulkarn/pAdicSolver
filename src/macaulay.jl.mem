        - export macaulay_mat, qr_basis, solve_macaulay, coefficient_matrix
        - 
        - using LinearAlgebra
        - using DynamicPolynomials
        - 
        - function is_not_homogeneous(p)
   212691     L = [degree(t) for t in p]
  2089461     maximum(L) != minimum(L)
        - end
        - 
        - 
        - # Creates the macaulay matrix of the polynomial system P.
        - function macaulay_mat(P, L::AbstractVector, X, ish = false )
106658097     d = maximum([degree(m) for m in L])
        0     if ish
        0         Q = [monomials(X,d-degree(P[i])) for i in 1:length(P)]
        -     else
   186988         Q = [monomials(X,0:d-degree(P[i])) for i in 1:length(P)]
        -     end
        - 
        -     ### this looks like it can be optimized a bit.
        0     M = []
      560     for i in 1:length(P)
     1472         for m in Q[i]
        0             push!(M,P[i]*m)
        -         end
        -     end
        -     ###    
        0     return coefficient_matrix(M, L)
        - end
        - 
        - # AVI:
        - # Takes a list of polynomials and a basis of monomials and
        - # returns a matrix of coefficients corresponding to the
        - # monomial basis.
        - #
        - # AVI: Multivariate polynomials has a "coefficients" function.
        - # Should simplify this function a bit.
        - #
        - # AVI: The t.\alpha is the coefficient of the term.
        - #
        - # L -- list of monomials
        - import MultivariatePolynomials.coefficients
        - function coefficient_matrix(P::Vector, L)
  6285331     return Array(transpose(hcat([MultivariatePolynomials.coefficients(p, L) for p in P]...)))
        - end
        - 
        - 
        - 
        - # AVI: Main solver function, for us anyways.
        - # calls to:
        - # macaulay_mat
        - # qr_basis
        - # mult_matrix
        - # eigdiag
        - #------------
        - # call to the qr intrinsic uses float (not p-adic) arithmetic.
        - #-------------------
        - # INPUTS:
        - # P   -- polynomial system
        - # X   -- variables in the polynomial system
        - # rho -- monomial degree of the system. Default is the macaulay degree.
        - #
        - function solve_macaulay(P, X, rho =  sum(degree(P[i])-1 for i in 1:length(P)) + 1, test_mode=false )
  2652771     println()
 26423951     println("-- Degrees ", map(p->degree(p),P))
        0     ish = !any(is_not_homogeneous, P)
  1354826     println("-- Homogeneity ", ish)
        0     if ish
        0         L = [m for m in monomials(X, rho)]
        -     else
   178855         L = [m for m in monomials(X, 0:rho)]
        -     end
        -     # We also specifically designate the "monomial" of x0 in the computations.
        -     # in the affine case, the monomial x0 is just "1", in which case we mean take the
        -     # monomials whose degrees are not maximal.
        -     #
        -     # The KEY property of this monomial basis L0 is that for any element b, xi*b remains inside the
        -     # larger monomial basis L. That is,
        -     #                                         X ⋅ L0 ⊂ L
        0     Idx = idx(L)
        0     L0 = monomials_divisible_by_x0(L, ish)
   172729     IdL0 = [get(Idx, m,0) for m in L0]
        -     
        -     # START MAIN SOLVER
        -     t0 = time()
  6018494     println("-- Monomials ", length(L), " degree ", rho,"   ",time()-t0, "(s)"); t0 = time()
        - 
        0     R = macaulay_mat(P, L, X, ish)
     7440     println("-- Macaulay matrix ", size(R,1),"x",size(R,2),  "   ",time()-t0, "(s)"); t0 = time()
     1792     println("-- -- rank of Macaulay matrix ", rank(matrix(R)))
        - 
        0     N = nullspace(R)
     4944     println("-- Null space ",size(N,1),"x",size(N,2), "   ",time()-t0, "(s)"); t0 = time()
        - 
        - 
        -     # The idea of the QR step is two-fold:
        -     # 1: Choose a well-conditioned *monomial* basis for the algebra from a given spanning set (here, IdL0).
        -     #    This is accomplished by pivoting. The columns corresponding to F.p[1:size(N,2)] form a well-conditioned
        -     #    submatrix.
        -     #
        -     # 2: Present the algebra in Q-coordinates, which has many zeroes. Note that the choice of coordinates
        -     #    is not important in the final step, when the eigenvalues are calulated.
        -     #
        0     F, Nr = iwasawa_step(N, IdL0)
        0     B = permute_and_divide_by_x0(L0, F, ish)
        -     
     4224     println("-- Qr basis ",  length(B), "   ",time()-t0, "(s)"); t0 = time()
        - 
        -     
        0     M = mult_matrices(B, X, Nr, L, ish)
  1399823     println("-- Mult matrices ",time()-t0, "(s)"); t0 = time()
        - 
        0     if test_mode
        0         println("TESTING MODE: Computation incomplete. Returning partial result.")
        0         return M, F, B, N, Nr, R
        -     end
        - 
        0     Xi = normalized_simultaneous_eigenvalues(M,ish)
   429088     println("-- Eigen diag",  "   ",time()-t0, "(s)"); t0 = time()
        - 
        -     # In the affine system, the distinguished monomial (i.e, "1" for that case) does not correspond
        -     # to a coordinate.
      192     if ish return Xi else return  Xi[:,2:size(Xi,2)] end
        - end
        - 
        - 
        - # Dispatcher for doing the right iwasawa algorithm
        - function iwasawa_step(N :: Array{T,2} where T <: Number, IdL0)
        -     F = qr( Array(transpose(N[IdL0,:])) , Val(true))
        -     return F, N*F.Q
        - end
        - 
        - 
        - # Dispatcher for doing the right iwasawa algorithm
        - function iwasawa_step(N :: Array{padic,2} , IdL0)
        0     F = qr( Array(transpose(N[IdL0,:])) , Val(true))
      224     return F, N*inv(matrix(parent(N[1,1]), Array(transpose(F.Q)))).entries
        - end
        - 
